<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom" xml:lang="en">
<title type="text">Pete Hare</title>
<generator uri="https://github.com/jekyll/jekyll">Jekyll</generator>
<link rel="self" type="application/atom+xml" href="/feed.xml" />
<link rel="alternate" type="text/html" href="" />
<updated>2014-12-20T00:49:55-08:00</updated>
<id>/</id>
<author>
  <name>Pete Hare</name>
  <uri>/</uri>
  <email>harepj@gmail.com</email>
</author>


  

<entry>
  <title type="html"><![CDATA[Inline NSTextAttachment rendering in UITextView]]></title>
  <link rel="alternate" type="text/html" href="/post-title/" />
  <id>/post-title</id>
  <published>2014-12-19T17:32:09-08:00</published>
  <updated>2014-12-19T17:32:09-08:00</updated>
  <author>
    <name>Pete Hare</name>
    <uri></uri>
    <email>harepj@gmail.com</email>
  </author>
  <content type="html">&lt;h1 id=&quot;background&quot;&gt;Background&lt;/h1&gt;

&lt;p&gt;Apple’s Mail app for iOS seems to treat a single email address as a single character once entered. When you try to edit the text, the whole email is selected.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/Screen Shot 2014-12-19 at 8.55.14 PM.png&quot; alt=&quot;Email selecting&quot; /&gt;&lt;/p&gt;

&lt;p&gt;In an attempt to mimic the email entry behaviour of the Mail app, I came upon an issue when rendering instances of &lt;code&gt;NSTextAttachment&lt;/code&gt; inside a &lt;code&gt;UITextView&lt;/code&gt;.&lt;/p&gt;

&lt;h1 id=&quot;the-problem&quot;&gt;The Problem&lt;/h1&gt;

&lt;p&gt;To accomplish this, I attempted to take snapshots of the entered text, and render it as a text attachment inline with any additional text (I might write another post about the data source behaviour another time).&lt;/p&gt;

&lt;p&gt;The technique worked very well, except I found my text baseline was being thrown around a bit.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/Screen Shot 2014-12-19 at 9.02.50 PM.png&quot; alt=&quot;NSTextAttachment Baseline&quot; /&gt;&lt;/p&gt;

&lt;p&gt;This had me stumped for a while. The &lt;code&gt;UIImage&lt;/code&gt; that I had generated for the &lt;code&gt;NSTextAttachment&lt;/code&gt; was simply a &lt;code&gt;UILabel&lt;/code&gt; rendered offscreen, and then sized to fit. Given that all my font sizes and string attributes matched up, there should not be any reason for the baselines to not line up &lt;em&gt;perfectly&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;I set a background colour on the label to investigate:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/Screen Shot 2014-12-19 at 9.08.51 PM.png&quot; alt=&quot;Background colour showing baseline&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Aha! It looks like by default, the &lt;code&gt;UITextView&lt;/code&gt; renders instances of &lt;code&gt;NSTextAttachment&lt;/code&gt; on the &lt;em&gt;baseline&lt;/em&gt;, extending upwards. This means the larger the image, the further down my baseline of the following text will be pushed.&lt;/p&gt;

&lt;h1 id=&quot;the-solution&quot;&gt;The Solution&lt;/h1&gt;

&lt;p&gt;After spending far too much time delving into various TextKit classes, I came up with a fairly straightforward solution.&lt;/p&gt;

&lt;p&gt;I started checking out the &lt;code&gt;NSLayoutManager&lt;/code&gt; class, as that seemed to control how glyphs and characters are positioned in a text container. However it turns out that the &lt;code&gt;NSTextAttachment&lt;/code&gt; class already has a method returning it’s bounds:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;-attachmentBoundsForTextContainer:proposedLineFragment:glyphPosition:characterIndex:
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;So, I made a simple subclass of &lt;code&gt;NSTextAttachment&lt;/code&gt; which exposes a property for adjusting the y-offset of the attachment bounds.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;@interface InlineTextAttachment : NSTextAttachment

@property CGFloat fontDescender;

@end

@implementation InlineTextAttachment

- (CGRect)attachmentBoundsForTextContainer:(NSTextContainer *)textContainer proposedLineFragment:(CGRect)lineFrag glyphPosition:(CGPoint)position characterIndex:(NSUInteger)charIndex {
	CGRect superRect = [super attachmentBoundsForTextContainer:textContainer proposedLineFragment:lineFrag glyphPosition:position characterIndex:charIndex];
	superRect.origin.y = self.fontDescender;
	return superRect;
}

@end
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Using this subclass now, I can grab the descender value from the font I’m using in my attributed string.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;UIImage *labelImage = [label snapshotImageAfterScreenUpdates:NO];
InlineTextAttachment *attachment = [[InlineTextAttachment alloc] initWithData:nil ofType:nil];
UIFont *font = [aString attribute:NSFontAttributeName atIndex:0 effectiveRange:NULL];

attachment.fontDescender = font.descender;
attachment.image = labelImage;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;And bingo! The descender height was exactly the offset I needed to get all my &lt;code&gt;NSTextAttachment&lt;/code&gt; instances to line up nicely with my existing text.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/Screen Shot 2014-12-20 at 12.48.50 AM.png&quot; alt=&quot;Final result&quot; /&gt;&lt;/p&gt;

  &lt;p&gt;&lt;a href=&quot;/post-title/&quot;&gt;Inline NSTextAttachment rendering in UITextView&lt;/a&gt; was originally published by Pete Hare at &lt;a href=&quot;&quot;&gt;Pete Hare&lt;/a&gt; on December 19, 2014.&lt;/p&gt;</content>
</entry>

</feed>